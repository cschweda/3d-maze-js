<!DOCTYPE html>
<html>
  <head>
    <title>TRS-80 Style Maze</title>
    <style>
      body {
        background-color: black;
        color: white;
        font-family: monospace;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        overflow: hidden;
      }
      #gameContainer {
        display: flex;
        flex-direction: column;
        width: 640px;
        border: 2px solid white;
      }
      #mazeView {
        height: 400px;
        background-color: black;
        border-bottom: 2px solid white;
      }
      #minimapContainer {
        margin-top: 20px;
        text-align: center;
      }
      #minimap {
        background-color: black;
        border: 2px solid white;
        margin-top: 10px;
      }
      #textArea {
        height: 100px;
        padding: 10px;
        overflow-y: auto;
      }
      .info {
        margin-top: 20px;
        font-size: 14px;
        text-align: center;
      }
      #exitsDisplay {
        margin-top: 10px;
        font-size: 16px;
        background-color: black;
        padding: 8px;
        border: 1px solid #444;
        border-radius: 4px;
      }
      #mazeSelector {
        margin-bottom: 20px;
        background-color: #333;
        color: white;
        font-family: monospace;
        padding: 8px;
        border: 1px solid #666;
        border-radius: 4px;
      }
      #startScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
      }
      #startScreen h1 {
        color: #0f0;
        margin-bottom: 30px;
        text-shadow: 0 0 10px #0f0;
      }
      .maze-option {
        background-color: #222;
        border: 1px solid #444;
        color: white;
        padding: 10px 15px;
        margin: 5px;
        cursor: pointer;
        width: 300px;
        text-align: center;
        transition: all 0.3s;
      }
      .maze-option:hover {
        background-color: #444;
        border-color: #0f0;
      }
      .maze-list {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
      }
      .option-group {
        margin-top: 30px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .option-title {
        margin-bottom: 10px;
        color: #0f0;
      }
      .generate-option {
        background-color: #333;
        margin-top: 30px;
      }
    </style>
  </head>
  <body>
    <div id="startScreen">
      <h1>TRS-80 STYLE MAZE EXPLORER</h1>
      <div class="option-group">
        <div class="option-title">SELECT A MAZE:</div>
        <div class="maze-list" id="mazeList">
          <!-- Maze options will be added here by JavaScript -->
        </div>
      </div>
      <div class="maze-option generate-option" id="generateRandomMaze">
        GENERATE RANDOM MAZE
      </div>
    </div>

    <div id="gameContainer">
      <canvas id="mazeView" width="640" height="400"></canvas>
      <div id="textArea">Welcome to the Maze. Use arrow keys to navigate.</div>
    </div>

    <div id="minimapContainer">
      <div>MAZE MAP</div>
      <canvas id="minimap" width="200" height="200"></canvas>
      <div id="exitsDisplay">Checking exits...</div>
    </div>

    <div class="info">TRS-80 Style Maze Explorer • Use arrow keys to move</div>

    <script>
      // Maze Generator and Game Logic
      class MazeGame {
        constructor(options = {}) {
          this.isCustomMaze = !!options.mazeData;
          
          if (this.isCustomMaze) {
            // Load from custom maze data
            const mazeData = options.mazeData;
            this.width = mazeData.width;
            this.height = mazeData.height;
            this.maze = mazeData.layout;
            
            // Set player start position
            this.player = {
              x: mazeData.playerStart.x,
              y: mazeData.playerStart.y,
              direction: mazeData.playerStart.direction
            };
            
            // Set exit position
            this.exit = {
              x: mazeData.exit.x,
              y: mazeData.exit.y
            };
            
            // Ensure exit is marked in the maze
            this.maze[this.exit.y][this.exit.x] = "E";
          } else {
            // Generate random maze
            this.width = options.width || 20;
            this.height = options.height || 20;
            this.maze = this.generateMaze(this.width, this.height);
            this.player = {
              x: 1,
              y: 1,
              direction: 0, // 0 = North, 1 = East, 2 = South, 3 = West
            };
            this.exit = {
              x: this.width - 2,
              y: this.height - 2,
            };
          }
          
          this.canvas = document.getElementById("mazeView");
          this.ctx = this.canvas.getContext("2d");
          this.minimapCanvas = document.getElementById("minimap");
          this.minimapCtx = this.minimapCanvas.getContext("2d");
          this.textArea = document.getElementById("textArea");
          this.exitsDisplay = document.getElementById("exitsDisplay");

          // Animation properties
          this.isAnimating = false;
          this.animationProgress = 0;
          this.animationType = null; // 'move', 'turn-left', 'turn-right'
          this.animationStartTime = 0;
          this.animationDuration = 300; // milliseconds
          this.lastFrameTime = 0;
          this.targetX = this.player.x;
          this.targetY = this.player.y;
          this.startX = this.player.x;
          this.startY = this.player.y;
          this.startDirection = this.player.direction;
          this.targetDirection = this.player.direction;

          this.setupEventListeners();
          this.render();
        }

        // Maze Generation using Depth-First Search with guaranteed solution
        generateMaze(width, height) {
          // Initialize maze with all walls
          let maze = Array(height)
            .fill()
            .map(() => Array(width).fill("#"));

          // Define start and exit points
          const startX = 1;
          const startY = 1;
          const exitX = width - 2;
          const exitY = height - 2;

          // Mark the start position
          maze[startY][startX] = " ";

          // Use a modified DFS algorithm to ensure a path from start to exit
          const visited = new Set();
          visited.add(`${startX},${startY}`);
          
          // First, ensure there's a path from start to exit
          this.ensurePathExists(maze, startX, startY, exitX, exitY, visited, width, height);
          
          // Then, fill in the rest of the maze with random paths
          this.fillRemainingMaze(maze, visited, width, height);

          // Set exit cell
          maze[exitY][exitX] = "E";

          return maze;
        }
        
        // Helper method to ensure a path exists from start to exit
        ensurePathExists(maze, startX, startY, exitX, exitY, visited, width, height) {
          // If we've reached very close to the exit, make the final connection
          if (Math.abs(startX - exitX) <= 2 && Math.abs(startY - exitY) <= 2) {
            // Make a direct path to the exit
            const dx = exitX - startX;
            const dy = exitY - startY;
            
            // Carve a straight path
            if (dx !== 0) {
              // Horizontal connection
              const stepX = dx > 0 ? 1 : -1;
              for (let x = startX + stepX; x !== exitX + stepX; x += stepX) {
                maze[startY][x] = " ";
                visited.add(`${x},${startY}`);
              }
            }
            
            if (dy !== 0) {
              // Vertical connection
              const stepY = dy > 0 ? 1 : -1;
              for (let y = startY + stepY; y !== exitY + stepY; y += stepY) {
                maze[y][exitX] = " ";
                visited.add(`${exitX},${y}`);
              }
            }
            
            return true;
          }
          
          // Directions to try, prioritizing moving towards the exit
          const directions = [
            { dx: 0, dy: -2 }, // Up
            { dx: 2, dy: 0 },  // Right
            { dx: 0, dy: 2 },  // Down
            { dx: -2, dy: 0 }  // Left
          ];
          
          // Sort directions based on how much closer they get us to the exit
          directions.sort((a, b) => {
            const distA = Math.abs((startX + a.dx) - exitX) + Math.abs((startY + a.dy) - exitY);
            const distB = Math.abs((startX + b.dx) - exitX) + Math.abs((startY + b.dy) - exitY);
            return distA - distB;
          });
          
          for (const dir of directions) {
            const nx = startX + dir.dx;
            const ny = startY + dir.dy;
            
            // Skip if out of bounds or already visited
            if (!this.isValidCell(nx, ny, width, height) || visited.has(`${nx},${ny}`)) {
              continue;
            }
            
            // Carve the path
            maze[startY + dir.dy/2][startX + dir.dx/2] = " ";
            maze[ny][nx] = " ";
            visited.add(`${nx},${ny}`);
            
            // Recursively continue path finding
            if (this.ensurePathExists(maze, nx, ny, exitX, exitY, visited, width, height)) {
              return true;
            }
          }
          
          return false;
        }
        
        // Helper method to fill in the rest of the maze with random paths
        fillRemainingMaze(maze, visited, width, height) {
          // Standard DFS algorithm to fill in the rest of the maze
          const stack = Array.from(visited).map(coord => {
            const [x, y] = coord.split(',').map(Number);
            return { x, y };
          });
          
          while (stack.length > 0) {
            const current = stack[stack.length - 1];
            
            // Check neighbors (up, right, down, left)
            const neighbors = [];
            const directions = [
              { dx: 0, dy: -2 }, // Up
              { dx: 2, dy: 0 }, // Right
              { dx: 0, dy: 2 }, // Down
              { dx: -2, dy: 0 }, // Left
            ];
            
            for (const dir of directions) {
              const nx = current.x + dir.dx;
              const ny = current.y + dir.dy;
              
              // Check if neighbor is valid and unvisited
              if (
                this.isValidCell(nx, ny, width, height) &&
                maze[ny][nx] === "#" &&
                !visited.has(`${nx},${ny}`)
              ) {
                neighbors.push({
                  x: nx,
                  y: ny,
                  dx: dir.dx / 2,
                  dy: dir.dy / 2,
                });
              }
            }
            
            if (neighbors.length > 0) {
              // Choose a random neighbor
              const next = neighbors[Math.floor(Math.random() * neighbors.length)];
              
              // Create path between current and next
              maze[current.y + next.dy][current.x + next.dx] = " ";
              maze[next.y][next.x] = " ";
              
              // Mark as visited
              visited.add(`${next.x},${next.y}`);
              
              // Push next cell to stack
              stack.push({ x: next.x, y: next.y });
            } else {
              // Dead end, backtrack
              stack.pop();
            }
          }
        }
        
        // Helper method to check if a cell position is valid within the maze
        isValidCell(x, y, width, height) {
          return x > 0 && x < width - 1 && y > 0 && y < height - 1;
        }

        // Handle key presses
        setupEventListeners() {
          document.addEventListener("keydown", (e) => {
            // Only process new movement if not currently animating
            if (!this.isAnimating) {
              switch (e.key) {
                case "ArrowUp":
                  this.moveForward();
                  break;
                case "ArrowDown":
                  this.moveBackward();
                  break;
                case "ArrowLeft":
                  this.turnLeft();
                  break;
                case "ArrowRight":
                  this.turnRight();
                  break;
              }
            }
          });

          // Set up animation loop
          requestAnimationFrame(this.animationLoop.bind(this));
        }

        // Animation loop
        animationLoop(timestamp) {
          // Calculate delta time
          if (!this.lastFrameTime) this.lastFrameTime = timestamp;
          const deltaTime = timestamp - this.lastFrameTime;
          this.lastFrameTime = timestamp;

          if (this.isAnimating) {
            // Update animation progress
            const elapsed = timestamp - this.animationStartTime;
            this.animationProgress = Math.min(
              elapsed / this.animationDuration,
              1
            );

            // If animation is complete
            if (this.animationProgress >= 1) {
              this.isAnimating = false;
              this.animationProgress = 0;

              // Finalize the movement
              if (this.animationType === "move") {
                this.player.x = this.targetX;
                this.player.y = this.targetY;
              } else if (this.animationType.startsWith("turn")) {
                this.player.direction = this.targetDirection;
              }
            }

            this.render();
          }

          // Continue animation loop
          requestAnimationFrame(this.animationLoop.bind(this));
        }

        // Start a new animation
        startAnimation(type) {
          this.isAnimating = true;
          this.animationType = type;
          this.animationStartTime = performance.now();
          this.animationProgress = 0;
        }

        // Movement and turning functions
        moveForward() {
          const dx = [0, 1, 0, -1]; // Direction vectors
          const dy = [-1, 0, 1, 0];

          const newX = this.player.x + dx[this.player.direction];
          const newY = this.player.y + dy[this.player.direction];

          if (this.maze[newY][newX] !== "#") {
            // Store start and target positions for animation
            this.startX = this.player.x;
            this.startY = this.player.y;
            this.targetX = newX;
            this.targetY = newY;

            // Start the movement animation
            this.startAnimation("move");

            if (this.maze[newY][newX] === "E") {
              this.textArea.innerHTML =
                "Congratulations! You've reached the exit!";
            } else {
              this.textArea.innerHTML = "Moving forward...";
            }
          } else {
            this.textArea.innerHTML = "You can't move through walls!";
          }
        }

        moveBackward() {
          const dx = [0, -1, 0, 1]; // Opposite direction vectors
          const dy = [1, 0, -1, 0];

          const newX = this.player.x + dx[this.player.direction];
          const newY = this.player.y + dy[this.player.direction];

          if (this.maze[newY][newX] !== "#") {
            // Store start and target positions for animation
            this.startX = this.player.x;
            this.startY = this.player.y;
            this.targetX = newX;
            this.targetY = newY;

            // Start the movement animation
            this.startAnimation("move");

            this.textArea.innerHTML = "Moving backward...";
          } else {
            this.textArea.innerHTML = "You can't move through walls!";
          }
        }

        turnLeft() {
          this.startDirection = this.player.direction;
          this.targetDirection = (this.player.direction + 3) % 4;
          this.startAnimation("turn-left");
          this.textArea.innerHTML = "Turning left...";
        }

        turnRight() {
          this.startDirection = this.player.direction;
          this.targetDirection = (this.player.direction + 1) % 4;
          this.startAnimation("turn-right");
          this.textArea.innerHTML = "Turning right...";
        }

        // Get current interpolated position and direction for smooth animations
        getCurrentPosition() {
          if (!this.isAnimating) {
            return {
              x: this.player.x,
              y: this.player.y,
              direction: this.player.direction,
            };
          }

          // Apply easing function for smoother movement
          const easeProgress = this.easeInOutQuad(this.animationProgress);

          if (this.animationType === "move") {
            // Interpolate position
            const x = this.startX + (this.targetX - this.startX) * easeProgress;
            const y = this.startY + (this.targetY - this.startY) * easeProgress;
            return {
              x: x,
              y: y,
              direction: this.player.direction,
            };
          } else if (
            this.animationType === "turn-left" ||
            this.animationType === "turn-right"
          ) {
            // Calculate rotation interpolation
            let directionDiff = this.targetDirection - this.startDirection;
            if (this.animationType === "turn-left" && directionDiff > 0)
              directionDiff -= 4;
            if (this.animationType === "turn-right" && directionDiff < 0)
              directionDiff += 4;

            const currentDirection =
              (this.startDirection + directionDiff * easeProgress) % 4;
            return {
              x: this.player.x,
              y: this.player.y,
              direction: currentDirection,
            };
          }

          return {
            x: this.player.x,
            y: this.player.y,
            direction: this.player.direction,
          };
        }

        // Easing function for smoother animations
        easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        // Render the 3D view
        render() {
          // Clear the canvas
          this.ctx.fillStyle = "black";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw the first-person view
          this.drawFirstPersonView();

          // Draw the minimap
          this.drawMiniMap();

          // Update exits display
          this.updateExitsDisplay();
        }

        // Check for available exits from the current position
        checkAvailableExits() {
          const currentPos = this.getCurrentPosition();
          const x = Math.floor(currentPos.x);
          const y = Math.floor(currentPos.y);
          const exits = [];
          const directions = ["North", "East", "South", "West"];
          const dx = [0, 1, 0, -1];
          const dy = [-1, 0, 1, 0];

          for (let i = 0; i < 4; i++) {
            const newX = x + dx[i];
            const newY = y + dy[i];

            if (!this.checkWall(newX, newY)) {
              exits.push(directions[i]);
              if (this.isExit(newX, newY)) {
                exits[exits.length - 1] += " (EXIT)";
              }
            }
          }

          return exits;
        }

        // Update the exits display text
        updateExitsDisplay() {
          const exits = this.checkAvailableExits();
          let exitsText = "Available paths: ";

          if (exits.length === 0) {
            exitsText += "None (you're trapped!)";
          } else {
            exitsText += exits.join(", ");
          }

          this.exitsDisplay.innerHTML = exitsText;

          // Also display in the 3D view for easier reference
          this.ctx.fillStyle = "white";
          this.ctx.font = "14px monospace";
          this.ctx.fillText("Exits: " + exits.join(", "), 20, 380);
        }

        // Draw the 3D view
        drawFirstPersonView() {
          const viewWidth = this.canvas.width;
          const viewHeight = this.canvas.height;
          const currentPos = this.getCurrentPosition();

          // Direction vectors for checking walls
          const dx = [0, 1, 0, -1]; // N, E, S, W
          const dy = [-1, 0, 1, 0];

          // Get the fractional direction for smooth turning
          const directionInt = Math.floor(currentPos.direction);
          const directionFrac = currentPos.direction - directionInt;

          // Calculate direction vectors with interpolation for smooth turning
          const directionX = this.interpolateDirection(
            dx,
            directionInt,
            directionFrac
          );
          const directionY = this.interpolateDirection(
            dy,
            directionInt,
            directionFrac
          );

          // Check what walls are visible from current position
          const frontWall = this.checkWall(
            Math.floor(currentPos.x + directionX),
            Math.floor(currentPos.y + directionY)
          );

          const leftDir = (directionInt + 3) % 4;
          const leftWall = this.checkWall(
            Math.floor(currentPos.x + dx[leftDir]),
            Math.floor(currentPos.y + dy[leftDir])
          );

          const rightDir = (directionInt + 1) % 4;
          const rightWall = this.checkWall(
            Math.floor(currentPos.x + dx[rightDir]),
            Math.floor(currentPos.y + dy[rightDir])
          );

          // Draw floor and ceiling
          this.drawFloorAndCeiling();

          // Draw walls based on what's visible
          if (frontWall) {
            // Draw solid front wall
            this.ctx.fillStyle = "#555555";
            this.ctx.fillRect(100, 100, 440, 200);

            // Wall outline
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.rect(100, 100, 440, 200);
            this.ctx.stroke();

            // Exit sign if applicable
            if (
              this.isExit(
                Math.floor(currentPos.x + directionX),
                Math.floor(currentPos.y + directionY)
              )
            ) {
              this.ctx.fillStyle = "green";
              this.ctx.fillRect(290, 160, 60, 40);
              this.ctx.fillStyle = "white";
              this.ctx.font = "24px monospace";
              this.ctx.fillText("EXIT", 290, 190);
            }
          } else {
            // If there's no front wall, draw corridor

            // Draw floor
            this.ctx.fillStyle = "#333333";
            this.ctx.beginPath();
            this.ctx.moveTo(100, 300);
            this.ctx.lineTo(540, 300);
            this.ctx.lineTo(440, 250);
            this.ctx.lineTo(200, 250);
            this.ctx.closePath();
            this.ctx.fill();

            // Draw ceiling
            this.ctx.fillStyle = "#222222";
            this.ctx.beginPath();
            this.ctx.moveTo(100, 100);
            this.ctx.lineTo(540, 100);
            this.ctx.lineTo(440, 150);
            this.ctx.lineTo(200, 150);
            this.ctx.closePath();
            this.ctx.fill();

            // Draw side walls
            if (leftWall) {
              // Solid left wall
              this.ctx.fillStyle = "#444444";
              this.ctx.beginPath();
              this.ctx.moveTo(100, 100);
              this.ctx.lineTo(200, 150);
              this.ctx.lineTo(200, 250);
              this.ctx.lineTo(100, 300);
              this.ctx.closePath();
              this.ctx.fill();

              // Left wall outline
              this.ctx.strokeStyle = "white";
              this.ctx.lineWidth = 2;
              this.ctx.beginPath();
              this.ctx.moveTo(100, 100);
              this.ctx.lineTo(200, 150);
              this.ctx.lineTo(200, 250);
              this.ctx.lineTo(100, 300);
              this.ctx.closePath();
              this.ctx.stroke();
            }

            if (rightWall) {
              // Solid right wall
              this.ctx.fillStyle = "#444444";
              this.ctx.beginPath();
              this.ctx.moveTo(540, 100);
              this.ctx.lineTo(440, 150);
              this.ctx.lineTo(440, 250);
              this.ctx.lineTo(540, 300);
              this.ctx.closePath();
              this.ctx.fill();

              // Right wall outline
              this.ctx.strokeStyle = "white";
              this.ctx.lineWidth = 2;
              this.ctx.beginPath();
              this.ctx.moveTo(540, 100);
              this.ctx.lineTo(440, 150);
              this.ctx.lineTo(440, 250);
              this.ctx.lineTo(540, 300);
              this.ctx.closePath();
              this.ctx.stroke();
            }

            // Draw second level depth if no front wall
            const front2X = Math.floor(currentPos.x + 2 * directionX);
            const front2Y = Math.floor(currentPos.y + 2 * directionY);

            if (this.isInBounds(front2X, front2Y)) {
              const frontWall2 = this.checkWall(front2X, front2Y);

              if (frontWall2) {
                // Draw far front wall (solid)
                this.ctx.fillStyle = "#333333";
                this.ctx.beginPath();
                this.ctx.moveTo(200, 150);
                this.ctx.lineTo(440, 150);
                this.ctx.lineTo(440, 250);
                this.ctx.lineTo(200, 250);
                this.ctx.closePath();
                this.ctx.fill();

                // Wall outline
                this.ctx.strokeStyle = "white";
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.rect(200, 150, 240, 100);
                this.ctx.stroke();

                // Exit sign if applicable
                if (this.isExit(front2X, front2Y)) {
                  this.ctx.fillStyle = "green";
                  this.ctx.fillRect(305, 180, 30, 20);
                  this.ctx.fillStyle = "white";
                  this.ctx.font = "16px monospace";
                  this.ctx.fillText("EXIT", 305, 195);
                }
              } else {
                // Draw distant floor
                this.ctx.fillStyle = "#222222";
                this.ctx.beginPath();
                this.ctx.moveTo(200, 250);
                this.ctx.lineTo(440, 250);
                this.ctx.lineTo(320, 280);
                this.ctx.lineTo(320, 280);
                this.ctx.closePath();
                this.ctx.fill();

                // Draw distant ceiling
                this.ctx.fillStyle = "#111111";
                this.ctx.beginPath();
                this.ctx.moveTo(200, 150);
                this.ctx.lineTo(440, 150);
                this.ctx.lineTo(320, 120);
                this.ctx.lineTo(320, 120);
                this.ctx.closePath();
                this.ctx.fill();
              }

              // Draw corner walls
              const leftCornerDir = (directionInt + 3) % 4;
              const leftCornerWall = this.checkWall(
                Math.floor(currentPos.x + directionX + dx[leftCornerDir]),
                Math.floor(currentPos.y + directionY + dy[leftCornerDir])
              );

              const rightCornerDir = (directionInt + 1) % 4;
              const rightCornerWall = this.checkWall(
                Math.floor(currentPos.x + directionX + dx[rightCornerDir]),
                Math.floor(currentPos.y + directionY + dy[rightCornerDir])
              );

              // Draw corner walls if needed
              if (leftCornerWall) {
                this.ctx.fillStyle = "#3a3a3a";
                this.ctx.beginPath();
                this.ctx.moveTo(200, 150);
                this.ctx.lineTo(200, 250);
                this.ctx.closePath();
                this.ctx.stroke();
              }

              if (rightCornerWall) {
                this.ctx.fillStyle = "#3a3a3a";
                this.ctx.beginPath();
                this.ctx.moveTo(440, 150);
                this.ctx.lineTo(440, 250);
                this.ctx.closePath();
                this.ctx.stroke();
              }
            }
          }
        }

        // Draw floor and ceiling background
        drawFloorAndCeiling() {
          // Floor (bottom half)
          this.ctx.fillStyle = "#111111";
          this.ctx.fillRect(0, 200, this.canvas.width, 200);

          // Ceiling (top half)
          this.ctx.fillStyle = "#000000";
          this.ctx.fillRect(0, 0, this.canvas.width, 200);

          // Add perspective grid lines to floor
          this.ctx.strokeStyle = "#333333";
          this.ctx.lineWidth = 1;
          for (let i = 0; i < 5; i++) {
            const y = 200 + i * 40;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
          }
        }

        // Interpolate between direction vectors for smooth turning
        interpolateDirection(dirArray, dirIndex, fraction) {
          if (fraction === 0) return dirArray[dirIndex];

          const nextIndex = (dirIndex + 1) % 4;
          return (
            dirArray[dirIndex] * (1 - fraction) + dirArray[nextIndex] * fraction
          );
        }

        // Helper function to check if a cell contains a wall
        checkWall(x, y) {
          if (!this.isInBounds(x, y)) return true;
          return this.maze[y][x] === "#";
        }

        // Helper function to check if a cell is the exit
        isExit(x, y) {
          if (!this.isInBounds(x, y)) return false;
          return this.maze[y][x] === "E";
        }

        // Helper function to check if coordinates are within the maze bounds
        isInBounds(x, y) {
          return x >= 0 && x < this.width && y >= 0 && y < this.height;
        }

        // Draw a minimap
        drawMiniMap() {
          const mapSize = 200;
          const cellSize = 10; // Larger cell size for better visibility
          const currentPos = this.getCurrentPosition();

          // Clear the minimap canvas
          this.minimapCtx.fillStyle = "black";
          this.minimapCtx.fillRect(0, 0, mapSize, mapSize);

          // Draw maze cells
          for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
              if (this.maze[y][x] === "#") {
                this.minimapCtx.fillStyle = "white";
                this.minimapCtx.fillRect(
                  x * cellSize,
                  y * cellSize,
                  cellSize,
                  cellSize
                );
              } else if (this.maze[y][x] === "E") {
                this.minimapCtx.fillStyle = "green";
                this.minimapCtx.fillRect(
                  x * cellSize,
                  y * cellSize,
                  cellSize,
                  cellSize
                );
              } else if (
                x === Math.floor(currentPos.x) &&
                y === Math.floor(currentPos.y)
              ) {
                // Highlight the current path
                this.minimapCtx.fillStyle = "#444";
                this.minimapCtx.fillRect(
                  x * cellSize,
                  y * cellSize,
                  cellSize,
                  cellSize
                );
              }
            }
          }

          // Draw player as a directional triangle
          const directionInt = Math.floor(currentPos.direction);
          const directionFrac = currentPos.direction - directionInt;

          const dx = [0, 1, 0, -1]; // N, E, S, W
          const dy = [-1, 0, 1, 0];

          const directionX = this.interpolateDirection(
            dx,
            directionInt,
            directionFrac
          );
          const directionY = this.interpolateDirection(
            dy,
            directionInt,
            directionFrac
          );

          // Draw a triangle to represent the player and direction
          const triangleSize = cellSize * 0.9; // Size of the triangle
          const centerX = currentPos.x * cellSize + cellSize / 2;
          const centerY = currentPos.y * cellSize + cellSize / 2;

          // Calculate triangle points
          const frontX = centerX + directionX * triangleSize;
          const frontY = centerY + directionY * triangleSize;

          // Calculate perpendicular vector for the base of the triangle
          const perpX = -directionY;
          const perpY = directionX;

          // Calculate back corners of the triangle
          const backLeftX =
            centerX -
            (directionX * triangleSize) / 3 +
            (perpX * triangleSize) / 2;
          const backLeftY =
            centerY -
            (directionY * triangleSize) / 3 +
            (perpY * triangleSize) / 2;
          const backRightX =
            centerX -
            (directionX * triangleSize) / 3 -
            (perpX * triangleSize) / 2;
          const backRightY =
            centerY -
            (directionY * triangleSize) / 3 -
            (perpY * triangleSize) / 2;

          // Draw filled triangle
          this.minimapCtx.fillStyle = "red";
          this.minimapCtx.beginPath();
          this.minimapCtx.moveTo(frontX, frontY);
          this.minimapCtx.lineTo(backLeftX, backLeftY);
          this.minimapCtx.lineTo(backRightX, backRightY);
          this.minimapCtx.closePath();
          this.minimapCtx.fill();

          // Add white outline to make it stand out more
          this.minimapCtx.strokeStyle = "white";
          this.minimapCtx.lineWidth = 1;
          this.minimapCtx.stroke();

          // Add legend with larger text
          this.minimapCtx.font = "12px monospace";
          this.minimapCtx.fillStyle = "white";
          this.minimapCtx.fillText("■ Wall", 5, mapSize - 35);
          this.minimapCtx.fillStyle = "green";
          this.minimapCtx.fillText("■ Exit", 5, mapSize - 20);

          // Draw triangle symbol in legend
          this.minimapCtx.fillStyle = "red";
          this.minimapCtx.beginPath();
          this.minimapCtx.moveTo(80, mapSize - 35);
          this.minimapCtx.lineTo(70, mapSize - 25);
          this.minimapCtx.lineTo(90, mapSize - 25);
          this.minimapCtx.closePath();
          this.minimapCtx.fill();

          this.minimapCtx.fillStyle = "white";
          this.minimapCtx.fillText("Player", 95, mapSize - 28);

          // Display current coordinates
          this.minimapCtx.fillStyle = "white";
          this.minimapCtx.fillText(
            `Position: (${Math.floor(currentPos.x)},${Math.floor(
              currentPos.y
            )})`,
            5,
            mapSize - 5
          );
        }
      }

      // Maze loader and startup functionality
      class MazeLoader {
        constructor() {
          this.availableMazes = [];
          this.startScreen = document.getElementById("startScreen");
          this.mazeList = document.getElementById("mazeList");
          this.generateButton = document.getElementById("generateRandomMaze");
          
          this.setupEventListeners();
          this.loadAvailableMazes();
        }
        
        setupEventListeners() {
          this.generateButton.addEventListener("click", () => {
            this.startGame();
          });
        }
        
        async loadAvailableMazes() {
          try {
            // Prefefined list of maze files to load
            const mazeFiles = [
              { name: "Default Maze", path: "mazes/default.json" },
              { name: "Spiral Maze", path: "mazes/spiral.json" },
              { name: "Complex Maze", path: "mazes/complex.json" }
            ];
            
            for (const mazeInfo of mazeFiles) {
              try {
                const response = await fetch(mazeInfo.path);
                if (response.ok) {
                  const mazeData = await response.json();
                  this.availableMazes.push({
                    name: mazeData.name || mazeInfo.name,
                    data: mazeData,
                    path: mazeInfo.path
                  });
                }
              } catch (error) {
                console.error(`Error loading maze ${mazeInfo.path}:`, error);
              }
            }
            
            this.displayAvailableMazes();
          } catch (error) {
            console.error("Error loading mazes:", error);
          }
        }
        
        displayAvailableMazes() {
          // Clear existing options
          this.mazeList.innerHTML = "";
          
          // Add each maze as an option
          this.availableMazes.forEach(maze => {
            const option = document.createElement("div");
            option.className = "maze-option";
            option.textContent = maze.name;
            option.addEventListener("click", () => {
              this.startGame(maze.data);
            });
            this.mazeList.appendChild(option);
          });
          
          // Add message if no mazes found
          if (this.availableMazes.length === 0) {
            const message = document.createElement("div");
            message.textContent = "No custom mazes found. Use the generate option below.";
            message.style.color = "#aaa";
            message.style.padding = "10px";
            this.mazeList.appendChild(message);
          }
        }
        
        startGame(mazeData = null) {
          // Hide start screen
          this.startScreen.style.display = "none";
          
          // Create the game
          let game;
          if (mazeData) {
            game = new MazeGame({ mazeData });
          } else {
            game = new MazeGame({ width: 20, height: 20 });
          }
          
          // Store the game instance
          window.currentGame = game;
        }
      }

      // Create and start the game when the page loads
      window.onload = function () {
        // Check if there's a test maze in localStorage (from editor)
        const testMazeParam = new URLSearchParams(window.location.search).get('testMaze');
        
        if (testMazeParam === 'true' && localStorage.getItem('testMaze')) {
          try {
            const mazeData = JSON.parse(localStorage.getItem('testMaze'));
            // Create game directly with the test maze
            window.currentGame = new MazeGame({ mazeData });
            
            // Show notification about test mode
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.top = '10px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            notification.style.color = '#0f0';
            notification.style.padding = '10px 20px';
            notification.style.borderRadius = '5px';
            notification.style.fontFamily = 'monospace';
            notification.style.zIndex = '1000';
            notification.textContent = 'Testing custom maze from editor';
            document.body.appendChild(notification);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
              notification.style.opacity = '0';
              notification.style.transition = 'opacity 1s';
              setTimeout(() => notification.remove(), 1000);
            }, 5000);
          } catch (error) {
            console.error('Error loading test maze:', error);
            // Fall back to normal loader
            const loader = new MazeLoader();
          }
        } else {
          // Normal game startup with maze loader
          const loader = new MazeLoader();
        }
      };
    </script>
  </body>
</html>
